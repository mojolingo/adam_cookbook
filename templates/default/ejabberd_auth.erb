#!/usr/bin/env ruby

# This script is used by ejabberd to authenticate jabber users against the Memory service

$stdout.sync = true

require 'logger'
require 'faraday'
require 'faraday_middleware'

file = File.open "/var/log/ejabberd/auth.log", File::WRONLY | File::APPEND | File::CREAT
file.sync = true
$logger = Logger.new file
$logger.level = Logger::DEBUG

PACK_FORMAT = 'S>'

class Auth
  def initialize
    @conn = Faraday.new url: "<%= @memory_base_url %>" do |c|
      c.basic_auth "<%= @internal_username %>", "<%= @internal_password %>"
      c.adapter :net_http
      c.use FaradayMiddleware::ParseJson, content_type: 'application/json'
      c.response :raise_error
    end
  end

  def process_creds(operation, username, domain, password)
    case operation
    when 'auth'
      auth username, password
    when 'isuser'
      isuser username
    when 'setpass'
    else
      raise 'Invalid Operation'
    end

    respond true
  rescue
    respond
    raise
  end

  private

  def fetch_user(user_id)
    @conn.get "/users/#{user_id}.json"
  end

  def auth(user_id, token)
    $logger.debug "Checking creds for #{user_id} with password #{token}"
    if user_id == "adam" && token == "abc123"
      true
    else
      response = fetch_user user_id
      raise 'Password incorrect' unless response.body['authentication_token'] == token
    end
  rescue Faraday::Error::ResourceNotFound
    raise "User doesn't exist"
  end

  def isuser(user_id)
    $logger.debug "Checking if #{user_id} is a user"
    fetch_user user_id
    true
  rescue Faraday::Error::ResourceNotFound
    raise "User doesn't exist"
  end

  def respond(val = false)
    response = val ? 1 : 0
    $logger.debug "Responding with #{response}"
    data = [2, response].pack(PACK_FORMAT*2)
    $stdout.write data
  end
end

$logger.info "Starting ejabberd authentication service"

auth = Auth.new

begin
  loop do
    return if $stdin.eof?
    msg = $stdin.read 2
    next unless msg
    length = msg.unpack(PACK_FORMAT).first

    msg = $stdin.read length
    data = msg.split ':'

    auth.process_creds *data
  end
rescue => e
  $logger.error "#{e.class.name}: #{e.message}"
  $logger.error e.backtrace.join("\n\t")
end
